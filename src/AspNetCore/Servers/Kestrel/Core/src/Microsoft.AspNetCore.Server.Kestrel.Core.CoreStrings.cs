// <auto-generated>
using System.Reflection;


namespace Microsoft.AspNetCore.Server.Kestrel.Core
{
    internal static partial class CoreStrings
    {
        private static global::System.Resources.ResourceManager s_resourceManager;
        internal static global::System.Resources.ResourceManager ResourceManager => s_resourceManager ?? (s_resourceManager = new global::System.Resources.ResourceManager(typeof(CoreStrings)));
        internal static global::System.Globalization.CultureInfo Culture { get; set; }

        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        internal static string GetResourceString(string resourceKey, string defaultValue = null) =>  ResourceManager.GetString(resourceKey, Culture);

        private static string GetResourceString(string resourceKey, string[] formatterNames)
        {
           var value = GetResourceString(resourceKey);
           if (formatterNames != null)
           {
               for (var i = 0; i < formatterNames.Length; i++)
               {
                   value = value.Replace("{" + formatterNames[i] + "}", "{" + i + "}");
               }
           }
           return value;
        }

        /// <summary>Bad request.</summary>
        internal static string BadRequest => GetResourceString("BadRequest");
        /// <summary>Bad chunk size data.</summary>
        internal static string BadRequest_BadChunkSizeData => GetResourceString("BadRequest_BadChunkSizeData");
        /// <summary>Bad chunk suffix.</summary>
        internal static string BadRequest_BadChunkSuffix => GetResourceString("BadRequest_BadChunkSuffix");
        /// <summary>Chunked request incomplete.</summary>
        internal static string BadRequest_ChunkedRequestIncomplete => GetResourceString("BadRequest_ChunkedRequestIncomplete");
        /// <summary>The message body length cannot be determined because the final transfer coding was set to '{detail}' instead of 'chunked'.</summary>
        internal static string BadRequest_FinalTransferCodingNotChunked => GetResourceString("BadRequest_FinalTransferCodingNotChunked");
        /// <summary>The message body length cannot be determined because the final transfer coding was set to '{detail}' instead of 'chunked'.</summary>
        internal static string FormatBadRequest_FinalTransferCodingNotChunked(object detail)
           => string.Format(Culture, GetResourceString("BadRequest_FinalTransferCodingNotChunked", new [] { "detail" }), detail);

        /// <summary>Request headers too long.</summary>
        internal static string BadRequest_HeadersExceedMaxTotalSize => GetResourceString("BadRequest_HeadersExceedMaxTotalSize");
        /// <summary>Invalid characters in header name.</summary>
        internal static string BadRequest_InvalidCharactersInHeaderName => GetResourceString("BadRequest_InvalidCharactersInHeaderName");
        /// <summary>Invalid content length: {detail}</summary>
        internal static string BadRequest_InvalidContentLength_Detail => GetResourceString("BadRequest_InvalidContentLength_Detail");
        /// <summary>Invalid content length: {detail}</summary>
        internal static string FormatBadRequest_InvalidContentLength_Detail(object detail)
           => string.Format(Culture, GetResourceString("BadRequest_InvalidContentLength_Detail", new [] { "detail" }), detail);

        /// <summary>Invalid Host header.</summary>
        internal static string BadRequest_InvalidHostHeader => GetResourceString("BadRequest_InvalidHostHeader");
        /// <summary>Invalid Host header: '{detail}'</summary>
        internal static string BadRequest_InvalidHostHeader_Detail => GetResourceString("BadRequest_InvalidHostHeader_Detail");
        /// <summary>Invalid Host header: '{detail}'</summary>
        internal static string FormatBadRequest_InvalidHostHeader_Detail(object detail)
           => string.Format(Culture, GetResourceString("BadRequest_InvalidHostHeader_Detail", new [] { "detail" }), detail);

        /// <summary>Invalid request headers: missing final CRLF in header fields.</summary>
        internal static string BadRequest_InvalidRequestHeadersNoCRLF => GetResourceString("BadRequest_InvalidRequestHeadersNoCRLF");
        /// <summary>Invalid request header: '{detail}'</summary>
        internal static string BadRequest_InvalidRequestHeader_Detail => GetResourceString("BadRequest_InvalidRequestHeader_Detail");
        /// <summary>Invalid request header: '{detail}'</summary>
        internal static string FormatBadRequest_InvalidRequestHeader_Detail(object detail)
           => string.Format(Culture, GetResourceString("BadRequest_InvalidRequestHeader_Detail", new [] { "detail" }), detail);

        /// <summary>Invalid request line.</summary>
        internal static string BadRequest_InvalidRequestLine => GetResourceString("BadRequest_InvalidRequestLine");
        /// <summary>Invalid request line: '{detail}'</summary>
        internal static string BadRequest_InvalidRequestLine_Detail => GetResourceString("BadRequest_InvalidRequestLine_Detail");
        /// <summary>Invalid request line: '{detail}'</summary>
        internal static string FormatBadRequest_InvalidRequestLine_Detail(object detail)
           => string.Format(Culture, GetResourceString("BadRequest_InvalidRequestLine_Detail", new [] { "detail" }), detail);

        /// <summary>Invalid request target: '{detail}'</summary>
        internal static string BadRequest_InvalidRequestTarget_Detail => GetResourceString("BadRequest_InvalidRequestTarget_Detail");
        /// <summary>Invalid request target: '{detail}'</summary>
        internal static string FormatBadRequest_InvalidRequestTarget_Detail(object detail)
           => string.Format(Culture, GetResourceString("BadRequest_InvalidRequestTarget_Detail", new [] { "detail" }), detail);

        /// <summary>{detail} request contains no Content-Length or Transfer-Encoding header.</summary>
        internal static string BadRequest_LengthRequired => GetResourceString("BadRequest_LengthRequired");
        /// <summary>{detail} request contains no Content-Length or Transfer-Encoding header.</summary>
        internal static string FormatBadRequest_LengthRequired(object detail)
           => string.Format(Culture, GetResourceString("BadRequest_LengthRequired", new [] { "detail" }), detail);

        /// <summary>{detail} request contains no Content-Length header.</summary>
        internal static string BadRequest_LengthRequiredHttp10 => GetResourceString("BadRequest_LengthRequiredHttp10");
        /// <summary>{detail} request contains no Content-Length header.</summary>
        internal static string FormatBadRequest_LengthRequiredHttp10(object detail)
           => string.Format(Culture, GetResourceString("BadRequest_LengthRequiredHttp10", new [] { "detail" }), detail);

        /// <summary>Malformed request: invalid headers.</summary>
        internal static string BadRequest_MalformedRequestInvalidHeaders => GetResourceString("BadRequest_MalformedRequestInvalidHeaders");
        /// <summary>Method not allowed.</summary>
        internal static string BadRequest_MethodNotAllowed => GetResourceString("BadRequest_MethodNotAllowed");
        /// <summary>Request is missing Host header.</summary>
        internal static string BadRequest_MissingHostHeader => GetResourceString("BadRequest_MissingHostHeader");
        /// <summary>Multiple Content-Length headers.</summary>
        internal static string BadRequest_MultipleContentLengths => GetResourceString("BadRequest_MultipleContentLengths");
        /// <summary>Multiple Host headers.</summary>
        internal static string BadRequest_MultipleHostHeaders => GetResourceString("BadRequest_MultipleHostHeaders");
        /// <summary>Request line too long.</summary>
        internal static string BadRequest_RequestLineTooLong => GetResourceString("BadRequest_RequestLineTooLong");
        /// <summary>Reading the request headers timed out.</summary>
        internal static string BadRequest_RequestHeadersTimeout => GetResourceString("BadRequest_RequestHeadersTimeout");
        /// <summary>Request contains too many headers.</summary>
        internal static string BadRequest_TooManyHeaders => GetResourceString("BadRequest_TooManyHeaders");
        /// <summary>Unexpected end of request content.</summary>
        internal static string BadRequest_UnexpectedEndOfRequestContent => GetResourceString("BadRequest_UnexpectedEndOfRequestContent");
        /// <summary>Unrecognized HTTP version: '{detail}'</summary>
        internal static string BadRequest_UnrecognizedHTTPVersion => GetResourceString("BadRequest_UnrecognizedHTTPVersion");
        /// <summary>Unrecognized HTTP version: '{detail}'</summary>
        internal static string FormatBadRequest_UnrecognizedHTTPVersion(object detail)
           => string.Format(Culture, GetResourceString("BadRequest_UnrecognizedHTTPVersion", new [] { "detail" }), detail);

        /// <summary>Requests with 'Connection: Upgrade' cannot have content in the request body.</summary>
        internal static string BadRequest_UpgradeRequestCannotHavePayload => GetResourceString("BadRequest_UpgradeRequestCannotHavePayload");
        /// <summary>Failed to bind to http://[::]:{port} (IPv6Any). Attempting to bind to http://0.0.0.0:{port} instead.</summary>
        internal static string FallbackToIPv4Any => GetResourceString("FallbackToIPv4Any");
        /// <summary>Failed to bind to http://[::]:{port} (IPv6Any). Attempting to bind to http://0.0.0.0:{port} instead.</summary>
        internal static string FormatFallbackToIPv4Any(object port)
           => string.Format(Culture, GetResourceString("FallbackToIPv4Any", new [] { "port" }), port);

        /// <summary>Cannot write to response body after connection has been upgraded.</summary>
        internal static string ResponseStreamWasUpgraded => GetResourceString("ResponseStreamWasUpgraded");
        /// <summary>Kestrel does not support big-endian architectures.</summary>
        internal static string BigEndianNotSupported => GetResourceString("BigEndianNotSupported");
        /// <summary>Maximum request buffer size ({requestBufferSize}) must be greater than or equal to maximum request header size ({requestHeaderSize}).</summary>
        internal static string MaxRequestBufferSmallerThanRequestHeaderBuffer => GetResourceString("MaxRequestBufferSmallerThanRequestHeaderBuffer");
        /// <summary>Maximum request buffer size ({requestBufferSize}) must be greater than or equal to maximum request header size ({requestHeaderSize}).</summary>
        internal static string FormatMaxRequestBufferSmallerThanRequestHeaderBuffer(object requestBufferSize, object requestHeaderSize)
           => string.Format(Culture, GetResourceString("MaxRequestBufferSmallerThanRequestHeaderBuffer", new [] { "requestBufferSize", "requestHeaderSize" }), requestBufferSize, requestHeaderSize);

        /// <summary>Maximum request buffer size ({requestBufferSize}) must be greater than or equal to maximum request line size ({requestLineSize}).</summary>
        internal static string MaxRequestBufferSmallerThanRequestLineBuffer => GetResourceString("MaxRequestBufferSmallerThanRequestLineBuffer");
        /// <summary>Maximum request buffer size ({requestBufferSize}) must be greater than or equal to maximum request line size ({requestLineSize}).</summary>
        internal static string FormatMaxRequestBufferSmallerThanRequestLineBuffer(object requestBufferSize, object requestLineSize)
           => string.Format(Culture, GetResourceString("MaxRequestBufferSmallerThanRequestLineBuffer", new [] { "requestBufferSize", "requestLineSize" }), requestBufferSize, requestLineSize);

        /// <summary>Server has already started.</summary>
        internal static string ServerAlreadyStarted => GetResourceString("ServerAlreadyStarted");
        /// <summary>Unknown transport mode: '{mode}'.</summary>
        internal static string UnknownTransportMode => GetResourceString("UnknownTransportMode");
        /// <summary>Unknown transport mode: '{mode}'.</summary>
        internal static string FormatUnknownTransportMode(object mode)
           => string.Format(Culture, GetResourceString("UnknownTransportMode", new [] { "mode" }), mode);

        /// <summary>Invalid non-ASCII or control character in header: {character}</summary>
        internal static string InvalidAsciiOrControlChar => GetResourceString("InvalidAsciiOrControlChar");
        /// <summary>Invalid non-ASCII or control character in header: {character}</summary>
        internal static string FormatInvalidAsciiOrControlChar(object character)
           => string.Format(Culture, GetResourceString("InvalidAsciiOrControlChar", new [] { "character" }), character);

        /// <summary>Invalid Content-Length: "{value}". Value must be a positive integral number.</summary>
        internal static string InvalidContentLength_InvalidNumber => GetResourceString("InvalidContentLength_InvalidNumber");
        /// <summary>Invalid Content-Length: "{value}". Value must be a positive integral number.</summary>
        internal static string FormatInvalidContentLength_InvalidNumber(object value)
           => string.Format(Culture, GetResourceString("InvalidContentLength_InvalidNumber", new [] { "value" }), value);

        /// <summary>Value must be null or a non-negative number.</summary>
        internal static string NonNegativeNumberOrNullRequired => GetResourceString("NonNegativeNumberOrNullRequired");
        /// <summary>Value must be a non-negative number.</summary>
        internal static string NonNegativeNumberRequired => GetResourceString("NonNegativeNumberRequired");
        /// <summary>Value must be a positive number.</summary>
        internal static string PositiveNumberRequired => GetResourceString("PositiveNumberRequired");
        /// <summary>Value must be null or a positive number.</summary>
        internal static string PositiveNumberOrNullRequired => GetResourceString("PositiveNumberOrNullRequired");
        /// <summary>Unix socket path must be absolute.</summary>
        internal static string UnixSocketPathMustBeAbsolute => GetResourceString("UnixSocketPathMustBeAbsolute");
        /// <summary>Failed to bind to address {address}.</summary>
        internal static string AddressBindingFailed => GetResourceString("AddressBindingFailed");
        /// <summary>Failed to bind to address {address}.</summary>
        internal static string FormatAddressBindingFailed(object address)
           => string.Format(Culture, GetResourceString("AddressBindingFailed", new [] { "address" }), address);

        /// <summary>No listening endpoints were configured. Binding to {address} by default.</summary>
        internal static string BindingToDefaultAddress => GetResourceString("BindingToDefaultAddress");
        /// <summary>No listening endpoints were configured. Binding to {address} by default.</summary>
        internal static string FormatBindingToDefaultAddress(object address)
           => string.Format(Culture, GetResourceString("BindingToDefaultAddress", new [] { "address" }), address);

        /// <summary>HTTPS endpoints can only be configured using {methodName}.</summary>
        internal static string ConfigureHttpsFromMethodCall => GetResourceString("ConfigureHttpsFromMethodCall");
        /// <summary>HTTPS endpoints can only be configured using {methodName}.</summary>
        internal static string FormatConfigureHttpsFromMethodCall(object methodName)
           => string.Format(Culture, GetResourceString("ConfigureHttpsFromMethodCall", new [] { "methodName" }), methodName);

        /// <summary>A path base can only be configured using {methodName}.</summary>
        internal static string ConfigurePathBaseFromMethodCall => GetResourceString("ConfigurePathBaseFromMethodCall");
        /// <summary>A path base can only be configured using {methodName}.</summary>
        internal static string FormatConfigurePathBaseFromMethodCall(object methodName)
           => string.Format(Culture, GetResourceString("ConfigurePathBaseFromMethodCall", new [] { "methodName" }), methodName);

        /// <summary>Dynamic port binding is not supported when binding to localhost. You must either bind to 127.0.0.1:0 or [::1]:0, or both.</summary>
        internal static string DynamicPortOnLocalhostNotSupported => GetResourceString("DynamicPortOnLocalhostNotSupported");
        /// <summary>Failed to bind to address {endpoint}: address already in use.</summary>
        internal static string EndpointAlreadyInUse => GetResourceString("EndpointAlreadyInUse");
        /// <summary>Failed to bind to address {endpoint}: address already in use.</summary>
        internal static string FormatEndpointAlreadyInUse(object endpoint)
           => string.Format(Culture, GetResourceString("EndpointAlreadyInUse", new [] { "endpoint" }), endpoint);

        /// <summary>Invalid URL: '{url}'.</summary>
        internal static string InvalidUrl => GetResourceString("InvalidUrl");
        /// <summary>Invalid URL: '{url}'.</summary>
        internal static string FormatInvalidUrl(object url)
           => string.Format(Culture, GetResourceString("InvalidUrl", new [] { "url" }), url);

        /// <summary>Unable to bind to {address} on the {interfaceName} interface: '{error}'.</summary>
        internal static string NetworkInterfaceBindingFailed => GetResourceString("NetworkInterfaceBindingFailed");
        /// <summary>Unable to bind to {address} on the {interfaceName} interface: '{error}'.</summary>
        internal static string FormatNetworkInterfaceBindingFailed(object address, object interfaceName, object error)
           => string.Format(Culture, GetResourceString("NetworkInterfaceBindingFailed", new [] { "address", "interfaceName", "error" }), address, interfaceName, error);

        /// <summary>Overriding address(es) '{addresses}'. Binding to endpoints defined in {methodName} instead.</summary>
        internal static string OverridingWithKestrelOptions => GetResourceString("OverridingWithKestrelOptions");
        /// <summary>Overriding address(es) '{addresses}'. Binding to endpoints defined in {methodName} instead.</summary>
        internal static string FormatOverridingWithKestrelOptions(object addresses, object methodName)
           => string.Format(Culture, GetResourceString("OverridingWithKestrelOptions", new [] { "addresses", "methodName" }), addresses, methodName);

        /// <summary>Overriding endpoints defined in UseKestrel() because {settingName} is set to true. Binding to address(es) '{addresses}' instead.</summary>
        internal static string OverridingWithPreferHostingUrls => GetResourceString("OverridingWithPreferHostingUrls");
        /// <summary>Overriding endpoints defined in UseKestrel() because {settingName} is set to true. Binding to address(es) '{addresses}' instead.</summary>
        internal static string FormatOverridingWithPreferHostingUrls(object settingName, object addresses)
           => string.Format(Culture, GetResourceString("OverridingWithPreferHostingUrls", new [] { "settingName", "addresses" }), settingName, addresses);

        /// <summary>Unrecognized scheme in server address '{address}'. Only 'http://' is supported.</summary>
        internal static string UnsupportedAddressScheme => GetResourceString("UnsupportedAddressScheme");
        /// <summary>Unrecognized scheme in server address '{address}'. Only 'http://' is supported.</summary>
        internal static string FormatUnsupportedAddressScheme(object address)
           => string.Format(Culture, GetResourceString("UnsupportedAddressScheme", new [] { "address" }), address);

        /// <summary>Headers are read-only, response has already started.</summary>
        internal static string HeadersAreReadOnly => GetResourceString("HeadersAreReadOnly");
        /// <summary>An item with the same key has already been added.</summary>
        internal static string KeyAlreadyExists => GetResourceString("KeyAlreadyExists");
        /// <summary>Setting the header {name} is not allowed on responses with status code {statusCode}.</summary>
        internal static string HeaderNotAllowedOnResponse => GetResourceString("HeaderNotAllowedOnResponse");
        /// <summary>Setting the header {name} is not allowed on responses with status code {statusCode}.</summary>
        internal static string FormatHeaderNotAllowedOnResponse(object name, object statusCode)
           => string.Format(Culture, GetResourceString("HeaderNotAllowedOnResponse", new [] { "name", "statusCode" }), name, statusCode);

        /// <summary>{name} cannot be set because the response has already started.</summary>
        internal static string ParameterReadOnlyAfterResponseStarted => GetResourceString("ParameterReadOnlyAfterResponseStarted");
        /// <summary>{name} cannot be set because the response has already started.</summary>
        internal static string FormatParameterReadOnlyAfterResponseStarted(object name)
           => string.Format(Culture, GetResourceString("ParameterReadOnlyAfterResponseStarted", new [] { "name" }), name);

        /// <summary>Request processing didn't complete within the shutdown timeout.</summary>
        internal static string RequestProcessingAborted => GetResourceString("RequestProcessingAborted");
        /// <summary>Response Content-Length mismatch: too few bytes written ({written} of {expected}).</summary>
        internal static string TooFewBytesWritten => GetResourceString("TooFewBytesWritten");
        /// <summary>Response Content-Length mismatch: too few bytes written ({written} of {expected}).</summary>
        internal static string FormatTooFewBytesWritten(object written, object expected)
           => string.Format(Culture, GetResourceString("TooFewBytesWritten", new [] { "written", "expected" }), written, expected);

        /// <summary>Response Content-Length mismatch: too many bytes written ({written} of {expected}).</summary>
        internal static string TooManyBytesWritten => GetResourceString("TooManyBytesWritten");
        /// <summary>Response Content-Length mismatch: too many bytes written ({written} of {expected}).</summary>
        internal static string FormatTooManyBytesWritten(object written, object expected)
           => string.Format(Culture, GetResourceString("TooManyBytesWritten", new [] { "written", "expected" }), written, expected);

        /// <summary>The response has been aborted due to an unhandled application exception.</summary>
        internal static string UnhandledApplicationException => GetResourceString("UnhandledApplicationException");
        /// <summary>Writing to the response body is invalid for responses with status code {statusCode}.</summary>
        internal static string WritingToResponseBodyNotSupported => GetResourceString("WritingToResponseBodyNotSupported");
        /// <summary>Writing to the response body is invalid for responses with status code {statusCode}.</summary>
        internal static string FormatWritingToResponseBodyNotSupported(object statusCode)
           => string.Format(Culture, GetResourceString("WritingToResponseBodyNotSupported", new [] { "statusCode" }), statusCode);

        /// <summary>Connection shutdown abnormally.</summary>
        internal static string ConnectionShutdownError => GetResourceString("ConnectionShutdownError");
        /// <summary>Connection processing ended abnormally.</summary>
        internal static string RequestProcessingEndError => GetResourceString("RequestProcessingEndError");
        /// <summary>Cannot upgrade a non-upgradable request. Check IHttpUpgradeFeature.IsUpgradableRequest to determine if a request can be upgraded.</summary>
        internal static string CannotUpgradeNonUpgradableRequest => GetResourceString("CannotUpgradeNonUpgradableRequest");
        /// <summary>Request cannot be upgraded because the server has already opened the maximum number of upgraded connections.</summary>
        internal static string UpgradedConnectionLimitReached => GetResourceString("UpgradedConnectionLimitReached");
        /// <summary>IHttpUpgradeFeature.UpgradeAsync was already called and can only be called once per connection.</summary>
        internal static string UpgradeCannotBeCalledMultipleTimes => GetResourceString("UpgradeCannotBeCalledMultipleTimes");
        /// <summary>Request body too large.</summary>
        internal static string BadRequest_RequestBodyTooLarge => GetResourceString("BadRequest_RequestBodyTooLarge");
        /// <summary>The maximum request body size cannot be modified after the app has already started reading from the request body.</summary>
        internal static string MaxRequestBodySizeCannotBeModifiedAfterRead => GetResourceString("MaxRequestBodySizeCannotBeModifiedAfterRead");
        /// <summary>The maximum request body size cannot be modified after the request has been upgraded.</summary>
        internal static string MaxRequestBodySizeCannotBeModifiedForUpgradedRequests => GetResourceString("MaxRequestBodySizeCannotBeModifiedForUpgradedRequests");
        /// <summary>Value must be a positive TimeSpan.</summary>
        internal static string PositiveTimeSpanRequired => GetResourceString("PositiveTimeSpanRequired");
        /// <summary>Value must be a non-negative TimeSpan.</summary>
        internal static string NonNegativeTimeSpanRequired => GetResourceString("NonNegativeTimeSpanRequired");
        /// <summary>The request body rate enforcement grace period must be greater than {heartbeatInterval} second.</summary>
        internal static string MinimumGracePeriodRequired => GetResourceString("MinimumGracePeriodRequired");
        /// <summary>The request body rate enforcement grace period must be greater than {heartbeatInterval} second.</summary>
        internal static string FormatMinimumGracePeriodRequired(object heartbeatInterval)
           => string.Format(Culture, GetResourceString("MinimumGracePeriodRequired", new [] { "heartbeatInterval" }), heartbeatInterval);

        /// <summary>Synchronous operations are disallowed. Call ReadAsync or set AllowSynchronousIO to true instead.</summary>
        internal static string SynchronousReadsDisallowed => GetResourceString("SynchronousReadsDisallowed");
        /// <summary>Synchronous operations are disallowed. Call WriteAsync or set AllowSynchronousIO to true instead.</summary>
        internal static string SynchronousWritesDisallowed => GetResourceString("SynchronousWritesDisallowed");
        /// <summary>Value must be a positive number. To disable a minimum data rate, use null where a MinDataRate instance is expected.</summary>
        internal static string PositiveNumberOrNullMinDataRateRequired => GetResourceString("PositiveNumberOrNullMinDataRateRequired");
        /// <summary>Concurrent timeouts are not supported.</summary>
        internal static string ConcurrentTimeoutsNotSupported => GetResourceString("ConcurrentTimeoutsNotSupported");
        /// <summary>Timespan must be positive and finite.</summary>
        internal static string PositiveFiniteTimeSpanRequired => GetResourceString("PositiveFiniteTimeSpanRequired");
        /// <summary>An endpoint must be configured to serve at least one protocol.</summary>
        internal static string EndPointRequiresAtLeastOneProtocol => GetResourceString("EndPointRequiresAtLeastOneProtocol");
        /// <summary>HTTP/2 over TLS was not negotiated on an HTTP/2-only endpoint.</summary>
        internal static string EndPointHttp2NotNegotiated => GetResourceString("EndPointHttp2NotNegotiated");
        /// <summary>A dynamic table size of {size} octets is greater than the configured maximum size of {maxSize} octets.</summary>
        internal static string HPackErrorDynamicTableSizeUpdateTooLarge => GetResourceString("HPackErrorDynamicTableSizeUpdateTooLarge");
        /// <summary>A dynamic table size of {size} octets is greater than the configured maximum size of {maxSize} octets.</summary>
        internal static string FormatHPackErrorDynamicTableSizeUpdateTooLarge(object size, object maxSize)
           => string.Format(Culture, GetResourceString("HPackErrorDynamicTableSizeUpdateTooLarge", new [] { "size", "maxSize" }), size, maxSize);

        /// <summary>Index {index} is outside the bounds of the header field table.</summary>
        internal static string HPackErrorIndexOutOfRange => GetResourceString("HPackErrorIndexOutOfRange");
        /// <summary>Index {index} is outside the bounds of the header field table.</summary>
        internal static string FormatHPackErrorIndexOutOfRange(object index)
           => string.Format(Culture, GetResourceString("HPackErrorIndexOutOfRange", new [] { "index" }), index);

        /// <summary>Input data could not be fully decoded.</summary>
        internal static string HPackHuffmanErrorIncomplete => GetResourceString("HPackHuffmanErrorIncomplete");
        /// <summary>Input data contains the EOS symbol.</summary>
        internal static string HPackHuffmanErrorEOS => GetResourceString("HPackHuffmanErrorEOS");
        /// <summary>The destination buffer is not large enough to store the decoded data.</summary>
        internal static string HPackHuffmanErrorDestinationTooSmall => GetResourceString("HPackHuffmanErrorDestinationTooSmall");
        /// <summary>Huffman decoding error.</summary>
        internal static string HPackHuffmanError => GetResourceString("HPackHuffmanError");
        /// <summary>Decoded string length of {length} octets is greater than the configured maximum length of {maxStringLength} octets.</summary>
        internal static string HPackStringLengthTooLarge => GetResourceString("HPackStringLengthTooLarge");
        /// <summary>Decoded string length of {length} octets is greater than the configured maximum length of {maxStringLength} octets.</summary>
        internal static string FormatHPackStringLengthTooLarge(object length, object maxStringLength)
           => string.Format(Culture, GetResourceString("HPackStringLengthTooLarge", new [] { "length", "maxStringLength" }), length, maxStringLength);

        /// <summary>The header block was incomplete and could not be fully decoded.</summary>
        internal static string HPackErrorIncompleteHeaderBlock => GetResourceString("HPackErrorIncompleteHeaderBlock");
        /// <summary>The client sent a {frameType} frame with even stream ID {streamId}.</summary>
        internal static string Http2ErrorStreamIdEven => GetResourceString("Http2ErrorStreamIdEven");
        /// <summary>The client sent a {frameType} frame with even stream ID {streamId}.</summary>
        internal static string FormatHttp2ErrorStreamIdEven(object frameType, object streamId)
           => string.Format(Culture, GetResourceString("Http2ErrorStreamIdEven", new [] { "frameType", "streamId" }), frameType, streamId);

        /// <summary>The client sent a A PUSH_PROMISE frame.</summary>
        internal static string Http2ErrorPushPromiseReceived => GetResourceString("Http2ErrorPushPromiseReceived");
        /// <summary>The client sent a {frameType} frame to stream ID {streamId} before signaling of the header block for stream ID {headersStreamId}.</summary>
        internal static string Http2ErrorHeadersInterleaved => GetResourceString("Http2ErrorHeadersInterleaved");
        /// <summary>The client sent a {frameType} frame to stream ID {streamId} before signaling of the header block for stream ID {headersStreamId}.</summary>
        internal static string FormatHttp2ErrorHeadersInterleaved(object frameType, object streamId, object headersStreamId)
           => string.Format(Culture, GetResourceString("Http2ErrorHeadersInterleaved", new [] { "frameType", "streamId", "headersStreamId" }), frameType, streamId, headersStreamId);

        /// <summary>The client sent a {frameType} frame with stream ID 0.</summary>
        internal static string Http2ErrorStreamIdZero => GetResourceString("Http2ErrorStreamIdZero");
        /// <summary>The client sent a {frameType} frame with stream ID 0.</summary>
        internal static string FormatHttp2ErrorStreamIdZero(object frameType)
           => string.Format(Culture, GetResourceString("Http2ErrorStreamIdZero", new [] { "frameType" }), frameType);

        /// <summary>The client sent a {frameType} frame with stream ID different than 0.</summary>
        internal static string Http2ErrorStreamIdNotZero => GetResourceString("Http2ErrorStreamIdNotZero");
        /// <summary>The client sent a {frameType} frame with stream ID different than 0.</summary>
        internal static string FormatHttp2ErrorStreamIdNotZero(object frameType)
           => string.Format(Culture, GetResourceString("Http2ErrorStreamIdNotZero", new [] { "frameType" }), frameType);

        /// <summary>The client sent a {frameType} frame with padding longer than or with the same length as the sent data.</summary>
        internal static string Http2ErrorPaddingTooLong => GetResourceString("Http2ErrorPaddingTooLong");
        /// <summary>The client sent a {frameType} frame with padding longer than or with the same length as the sent data.</summary>
        internal static string FormatHttp2ErrorPaddingTooLong(object frameType)
           => string.Format(Culture, GetResourceString("Http2ErrorPaddingTooLong", new [] { "frameType" }), frameType);

        /// <summary>The client sent a {frameType} frame to closed stream ID {streamId}.</summary>
        internal static string Http2ErrorStreamClosed => GetResourceString("Http2ErrorStreamClosed");
        /// <summary>The client sent a {frameType} frame to closed stream ID {streamId}.</summary>
        internal static string FormatHttp2ErrorStreamClosed(object frameType, object streamId)
           => string.Format(Culture, GetResourceString("Http2ErrorStreamClosed", new [] { "frameType", "streamId" }), frameType, streamId);

        /// <summary>The client sent a {frameType} frame to stream ID {streamId} which is in the "half-closed (remote) state".</summary>
        internal static string Http2ErrorStreamHalfClosedRemote => GetResourceString("Http2ErrorStreamHalfClosedRemote");
        /// <summary>The client sent a {frameType} frame to stream ID {streamId} which is in the "half-closed (remote) state".</summary>
        internal static string FormatHttp2ErrorStreamHalfClosedRemote(object frameType, object streamId)
           => string.Format(Culture, GetResourceString("Http2ErrorStreamHalfClosedRemote", new [] { "frameType", "streamId" }), frameType, streamId);

        /// <summary>The client sent a {frameType} frame with dependency information that would cause stream ID {streamId} to depend on itself.</summary>
        internal static string Http2ErrorStreamSelfDependency => GetResourceString("Http2ErrorStreamSelfDependency");
        /// <summary>The client sent a {frameType} frame with dependency information that would cause stream ID {streamId} to depend on itself.</summary>
        internal static string FormatHttp2ErrorStreamSelfDependency(object frameType, object streamId)
           => string.Format(Culture, GetResourceString("Http2ErrorStreamSelfDependency", new [] { "frameType", "streamId" }), frameType, streamId);

        /// <summary>The client sent a {frameType} frame with length different than {expectedLength}.</summary>
        internal static string Http2ErrorUnexpectedFrameLength => GetResourceString("Http2ErrorUnexpectedFrameLength");
        /// <summary>The client sent a {frameType} frame with length different than {expectedLength}.</summary>
        internal static string FormatHttp2ErrorUnexpectedFrameLength(object frameType, object expectedLength)
           => string.Format(Culture, GetResourceString("Http2ErrorUnexpectedFrameLength", new [] { "frameType", "expectedLength" }), frameType, expectedLength);

        /// <summary>The client sent a SETTINGS frame with a length that is not a multiple of 6.</summary>
        internal static string Http2ErrorSettingsLengthNotMultipleOfSix => GetResourceString("Http2ErrorSettingsLengthNotMultipleOfSix");
        /// <summary>The client sent a SETTINGS frame with ACK set and length different than 0.</summary>
        internal static string Http2ErrorSettingsAckLengthNotZero => GetResourceString("Http2ErrorSettingsAckLengthNotZero");
        /// <summary>The client sent a SETTINGS frame with a value for parameter {parameter} that is out of range.</summary>
        internal static string Http2ErrorSettingsParameterOutOfRange => GetResourceString("Http2ErrorSettingsParameterOutOfRange");
        /// <summary>The client sent a SETTINGS frame with a value for parameter {parameter} that is out of range.</summary>
        internal static string FormatHttp2ErrorSettingsParameterOutOfRange(object parameter)
           => string.Format(Culture, GetResourceString("Http2ErrorSettingsParameterOutOfRange", new [] { "parameter" }), parameter);

        /// <summary>The client sent a WINDOW_UPDATE frame with a window size increment of 0.</summary>
        internal static string Http2ErrorWindowUpdateIncrementZero => GetResourceString("Http2ErrorWindowUpdateIncrementZero");
        /// <summary>The client sent a CONTINUATION frame not preceded by a HEADERS frame.</summary>
        internal static string Http2ErrorContinuationWithNoHeaders => GetResourceString("Http2ErrorContinuationWithNoHeaders");
        /// <summary>The client sent a {frameType} frame to idle stream ID {streamId}.</summary>
        internal static string Http2ErrorStreamIdle => GetResourceString("Http2ErrorStreamIdle");
        /// <summary>The client sent a {frameType} frame to idle stream ID {streamId}.</summary>
        internal static string FormatHttp2ErrorStreamIdle(object frameType, object streamId)
           => string.Format(Culture, GetResourceString("Http2ErrorStreamIdle", new [] { "frameType", "streamId" }), frameType, streamId);

        /// <summary>The client sent trailers containing one or more pseudo-header fields.</summary>
        internal static string Http2ErrorTrailersContainPseudoHeaderField => GetResourceString("Http2ErrorTrailersContainPseudoHeaderField");
        /// <summary>The client sent a header with uppercase characters in its name.</summary>
        internal static string Http2ErrorHeaderNameUppercase => GetResourceString("Http2ErrorHeaderNameUppercase");
        /// <summary>The client sent a trailer with uppercase characters in its name.</summary>
        internal static string Http2ErrorTrailerNameUppercase => GetResourceString("Http2ErrorTrailerNameUppercase");
        /// <summary>The client sent a HEADERS frame containing trailers without setting the END_STREAM flag.</summary>
        internal static string Http2ErrorHeadersWithTrailersNoEndStream => GetResourceString("Http2ErrorHeadersWithTrailersNoEndStream");
        /// <summary>Request headers missing one or more mandatory pseudo-header fields.</summary>
        internal static string Http2ErrorMissingMandatoryPseudoHeaderFields => GetResourceString("Http2ErrorMissingMandatoryPseudoHeaderFields");
        /// <summary>Pseudo-header field found in request headers after regular header fields.</summary>
        internal static string Http2ErrorPseudoHeaderFieldAfterRegularHeaders => GetResourceString("Http2ErrorPseudoHeaderFieldAfterRegularHeaders");
        /// <summary>Request headers contain unknown pseudo-header field.</summary>
        internal static string Http2ErrorUnknownPseudoHeaderField => GetResourceString("Http2ErrorUnknownPseudoHeaderField");
        /// <summary>Request headers contain response-specific pseudo-header field.</summary>
        internal static string Http2ErrorResponsePseudoHeaderField => GetResourceString("Http2ErrorResponsePseudoHeaderField");
        /// <summary>Request headers contain duplicate pseudo-header field.</summary>
        internal static string Http2ErrorDuplicatePseudoHeaderField => GetResourceString("Http2ErrorDuplicatePseudoHeaderField");
        /// <summary>Request headers contain connection-specific header field.</summary>
        internal static string Http2ErrorConnectionSpecificHeaderField => GetResourceString("Http2ErrorConnectionSpecificHeaderField");
        /// <summary>Unable to configure default https bindings because no IDefaultHttpsProvider service was provided.</summary>
        internal static string UnableToConfigureHttpsBindings => GetResourceString("UnableToConfigureHttpsBindings");
        /// <summary>Failed to authenticate HTTPS connection.</summary>
        internal static string AuthenticationFailed => GetResourceString("AuthenticationFailed");
        /// <summary>Authentication of the HTTPS connection timed out.</summary>
        internal static string AuthenticationTimedOut => GetResourceString("AuthenticationTimedOut");
        /// <summary>Certificate {thumbprint} cannot be used as an SSL server certificate. It has an Extended Key Usage extension but the usages do not include Server Authentication (OID 1.3.6.1.5.5.7.3.1).</summary>
        internal static string InvalidServerCertificateEku => GetResourceString("InvalidServerCertificateEku");
        /// <summary>Certificate {thumbprint} cannot be used as an SSL server certificate. It has an Extended Key Usage extension but the usages do not include Server Authentication (OID 1.3.6.1.5.5.7.3.1).</summary>
        internal static string FormatInvalidServerCertificateEku(object thumbprint)
           => string.Format(Culture, GetResourceString("InvalidServerCertificateEku", new [] { "thumbprint" }), thumbprint);

        /// <summary>Value must be a positive TimeSpan.</summary>
        internal static string PositiveTimeSpanRequired1 => GetResourceString("PositiveTimeSpanRequired1");
        /// <summary>The server certificate parameter is required.</summary>
        internal static string ServerCertificateRequired => GetResourceString("ServerCertificateRequired");
        /// <summary>No listening endpoints were configured. Binding to {address0} and {address1} by default.</summary>
        internal static string BindingToDefaultAddresses => GetResourceString("BindingToDefaultAddresses");
        /// <summary>No listening endpoints were configured. Binding to {address0} and {address1} by default.</summary>
        internal static string FormatBindingToDefaultAddresses(object address0, object address1)
           => string.Format(Culture, GetResourceString("BindingToDefaultAddresses", new [] { "address0", "address1" }), address0, address1);

        /// <summary>The requested certificate {subject} could not be found in {storeLocation}/{storeName} with AllowInvalid setting: {allowInvalid}.</summary>
        internal static string CertNotFoundInStore => GetResourceString("CertNotFoundInStore");
        /// <summary>The requested certificate {subject} could not be found in {storeLocation}/{storeName} with AllowInvalid setting: {allowInvalid}.</summary>
        internal static string FormatCertNotFoundInStore(object subject, object storeLocation, object storeName, object allowInvalid)
           => string.Format(Culture, GetResourceString("CertNotFoundInStore", new [] { "subject", "storeLocation", "storeName", "allowInvalid" }), subject, storeLocation, storeName, allowInvalid);

        /// <summary>The endpoint {endpointName} is missing the required 'Url' parameter.</summary>
        internal static string EndpointMissingUrl => GetResourceString("EndpointMissingUrl");
        /// <summary>The endpoint {endpointName} is missing the required 'Url' parameter.</summary>
        internal static string FormatEndpointMissingUrl(object endpointName)
           => string.Format(Culture, GetResourceString("EndpointMissingUrl", new [] { "endpointName" }), endpointName);

        /// <summary>Unable to configure HTTPS endpoint. No server certificate was specified, and the default developer certificate could not be found or is out of date.
        /// To generate a developer certificate run 'dotnet dev-certs https'. To trust the certificate (Windows and mac ...</summary>
        internal static string NoCertSpecifiedNoDevelopmentCertificateFound => GetResourceString("NoCertSpecifiedNoDevelopmentCertificateFound");
        /// <summary>The endpoint {endpointName} specified multiple certificate sources.</summary>
        internal static string MultipleCertificateSources => GetResourceString("MultipleCertificateSources");
        /// <summary>The endpoint {endpointName} specified multiple certificate sources.</summary>
        internal static string FormatMultipleCertificateSources(object endpointName)
           => string.Format(Culture, GetResourceString("MultipleCertificateSources", new [] { "endpointName" }), endpointName);

        /// <summary>Cannot write to the response body, the response has completed.</summary>
        internal static string WritingToResponseBodyAfterResponseCompleted => GetResourceString("WritingToResponseBodyAfterResponseCompleted");
        /// <summary>Reading the request body timed out due to data arriving too slowly. See MinRequestBodyDataRate.</summary>
        internal static string BadRequest_RequestBodyTimeout => GetResourceString("BadRequest_RequestBodyTimeout");
        /// <summary>The connection was aborted by the application.</summary>
        internal static string ConnectionAbortedByApplication => GetResourceString("ConnectionAbortedByApplication");
        /// <summary>The connection was aborted because the server is shutting down and request processing didn't complete within the time specified by HostOptions.ShutdownTimeout.</summary>
        internal static string ConnectionAbortedDuringServerShutdown => GetResourceString("ConnectionAbortedDuringServerShutdown");
        /// <summary>The connection was timed out by the server because the response was not read by the client at the specified minimum data rate.</summary>
        internal static string ConnectionTimedBecauseResponseMininumDataRateNotSatisfied => GetResourceString("ConnectionTimedBecauseResponseMininumDataRateNotSatisfied");
        /// <summary>The connection was timed out by the server.</summary>
        internal static string ConnectionTimedOutByServer => GetResourceString("ConnectionTimedOutByServer");
        /// <summary>The received frame size of {size} exceeds the limit {limit}.</summary>
        internal static string Http2ErrorFrameOverLimit => GetResourceString("Http2ErrorFrameOverLimit");
        /// <summary>The received frame size of {size} exceeds the limit {limit}.</summary>
        internal static string FormatHttp2ErrorFrameOverLimit(object size, object limit)
           => string.Format(Culture, GetResourceString("Http2ErrorFrameOverLimit", new [] { "size", "limit" }), size, limit);

        /// <summary>Tls 1.2 or later must be used for HTTP/2. {protocol} was negotiated.</summary>
        internal static string Http2ErrorMinTlsVersion => GetResourceString("Http2ErrorMinTlsVersion");
        /// <summary>Tls 1.2 or later must be used for HTTP/2. {protocol} was negotiated.</summary>
        internal static string FormatHttp2ErrorMinTlsVersion(object protocol)
           => string.Format(Culture, GetResourceString("Http2ErrorMinTlsVersion", new [] { "protocol" }), protocol);

        /// <summary>Invalid HTTP/2 connection preface.</summary>
        internal static string Http2ErrorInvalidPreface => GetResourceString("Http2ErrorInvalidPreface");
        /// <summary>Header name cannot be a null or empty string.</summary>
        internal static string InvalidEmptyHeaderName => GetResourceString("InvalidEmptyHeaderName");
        /// <summary>The connection or stream was aborted because a write operation was aborted with a CancellationToken.</summary>
        internal static string ConnectionOrStreamAbortedByCancellationToken => GetResourceString("ConnectionOrStreamAbortedByCancellationToken");
        /// <summary>The client sent a SETTINGS frame with a SETTINGS_INITIAL_WINDOW_SIZE that caused a flow-control window to exceed the maximum size.</summary>
        internal static string Http2ErrorInitialWindowSizeInvalid => GetResourceString("Http2ErrorInitialWindowSizeInvalid");
        /// <summary>The client sent a WINDOW_UPDATE frame that caused a flow-control window to exceed the maximum size.</summary>
        internal static string Http2ErrorWindowUpdateSizeInvalid => GetResourceString("Http2ErrorWindowUpdateSizeInvalid");
        /// <summary>The HTTP/2 connection faulted.</summary>
        internal static string Http2ConnectionFaulted => GetResourceString("Http2ConnectionFaulted");
        /// <summary>The client reset the request stream.</summary>
        internal static string Http2StreamResetByClient => GetResourceString("Http2StreamResetByClient");
        /// <summary>The request stream was aborted.</summary>
        internal static string Http2StreamAborted => GetResourceString("Http2StreamAborted");
        /// <summary>The client sent more data than what was available in the flow-control window.</summary>
        internal static string Http2ErrorFlowControlWindowExceeded => GetResourceString("Http2ErrorFlowControlWindowExceeded");
        /// <summary>CONNECT requests must not send :scheme or :path headers.</summary>
        internal static string Http2ErrorConnectMustNotSendSchemeOrPath => GetResourceString("Http2ErrorConnectMustNotSendSchemeOrPath");
        /// <summary>The Method '{method}' is invalid.</summary>
        internal static string Http2ErrorMethodInvalid => GetResourceString("Http2ErrorMethodInvalid");
        /// <summary>The Method '{method}' is invalid.</summary>
        internal static string FormatHttp2ErrorMethodInvalid(object method)
           => string.Format(Culture, GetResourceString("Http2ErrorMethodInvalid", new [] { "method" }), method);

        /// <summary>The request :path is invalid: '{path}'</summary>
        internal static string Http2StreamErrorPathInvalid => GetResourceString("Http2StreamErrorPathInvalid");
        /// <summary>The request :path is invalid: '{path}'</summary>
        internal static string FormatHttp2StreamErrorPathInvalid(object path)
           => string.Format(Culture, GetResourceString("Http2StreamErrorPathInvalid", new [] { "path" }), path);

        /// <summary>The request :scheme header '{requestScheme}' does not match the transport scheme '{transportScheme}'.</summary>
        internal static string Http2StreamErrorSchemeMismatch => GetResourceString("Http2StreamErrorSchemeMismatch");
        /// <summary>The request :scheme header '{requestScheme}' does not match the transport scheme '{transportScheme}'.</summary>
        internal static string FormatHttp2StreamErrorSchemeMismatch(object requestScheme, object transportScheme)
           => string.Format(Culture, GetResourceString("Http2StreamErrorSchemeMismatch", new [] { "requestScheme", "transportScheme" }), requestScheme, transportScheme);

        /// <summary>Less data received than specified in the Content-Length header.</summary>
        internal static string Http2StreamErrorLessDataThanLength => GetResourceString("Http2StreamErrorLessDataThanLength");
        /// <summary>More data received than specified in the Content-Length header.</summary>
        internal static string Http2StreamErrorMoreDataThanLength => GetResourceString("Http2StreamErrorMoreDataThanLength");
        /// <summary>An error occurred after the response headers were sent, a reset is being sent.</summary>
        internal static string Http2StreamErrorAfterHeaders => GetResourceString("Http2StreamErrorAfterHeaders");
        /// <summary>A new stream was refused because this connection has reached its stream limit.</summary>
        internal static string Http2ErrorMaxStreams => GetResourceString("Http2ErrorMaxStreams");
        /// <summary>A value greater than zero is required.</summary>
        internal static string GreaterThanZeroRequired => GetResourceString("GreaterThanZeroRequired");
        /// <summary>A value between {min} and {max} is required.</summary>
        internal static string ArgumentOutOfRange => GetResourceString("ArgumentOutOfRange");
        /// <summary>A value between {min} and {max} is required.</summary>
        internal static string FormatArgumentOutOfRange(object min, object max)
           => string.Format(Culture, GetResourceString("ArgumentOutOfRange", new [] { "min", "max" }), min, max);

        /// <summary>Dynamic tables size update did not occur at the beginning of the first header block.</summary>
        internal static string HPackErrorDynamicTableSizeUpdateNotAtBeginningOfHeaderBlock => GetResourceString("HPackErrorDynamicTableSizeUpdateNotAtBeginningOfHeaderBlock");
        /// <summary>The given buffer was too small to encode any headers.</summary>
        internal static string HPackErrorNotEnoughBuffer => GetResourceString("HPackErrorNotEnoughBuffer");
        /// <summary>The decoded integer exceeds the maximum value of Int32.MaxValue.</summary>
        internal static string HPackErrorIntegerTooBig => GetResourceString("HPackErrorIntegerTooBig");
        /// <summary>The client closed the connection.</summary>
        internal static string ConnectionAbortedByClient => GetResourceString("ConnectionAbortedByClient");
        /// <summary>A frame of type {frameType} was received after stream {streamId} was reset or aborted.</summary>
        internal static string Http2ErrorStreamAborted => GetResourceString("Http2ErrorStreamAborted");
        /// <summary>A frame of type {frameType} was received after stream {streamId} was reset or aborted.</summary>
        internal static string FormatHttp2ErrorStreamAborted(object frameType, object streamId)
           => string.Format(Culture, GetResourceString("Http2ErrorStreamAborted", new [] { "frameType", "streamId" }), frameType, streamId);

        /// <summary>HTTP protocol selection failed.</summary>
        internal static string ProtocolSelectionFailed => GetResourceString("ProtocolSelectionFailed");
        /// <summary>Server shutdown started during connection initialization.</summary>
        internal static string ServerShutdownDuringConnectionInitialization => GetResourceString("ServerShutdownDuringConnectionInitialization");
        /// <summary>Cannot call GetMemory() until response has started. Call HttpResponse.StartAsync() before calling GetMemory().</summary>
        internal static string StartAsyncBeforeGetMemory => GetResourceString("StartAsyncBeforeGetMemory");
        /// <summary>This feature is not supported for HTTP/2 requests except to disable it entirely by setting the rate to null.</summary>
        internal static string Http2MinDataRateNotSupported => GetResourceString("Http2MinDataRateNotSupported");
        /// <summary>The request trailers are not available yet. They may not be available until the full request body is read.</summary>
        internal static string RequestTrailersNotAvailable => GetResourceString("RequestTrailersNotAvailable");
        /// <summary>HTTP/2 over TLS is not supported on macOS due to missing ALPN support.</summary>
        internal static string HTTP2NoTlsOsx => GetResourceString("HTTP2NoTlsOsx");
        /// <summary>HTTP/2 over TLS is not supported on Windows 7 due to missing ALPN support.</summary>
        internal static string HTTP2NoTlsWin7 => GetResourceString("HTTP2NoTlsWin7");
        /// <summary>The HTTP/2 stream was reset by the application with error code {errorCode}.</summary>
        internal static string Http2StreamResetByApplication => GetResourceString("Http2StreamResetByApplication");
        /// <summary>The HTTP/2 stream was reset by the application with error code {errorCode}.</summary>
        internal static string FormatHttp2StreamResetByApplication(object errorCode)
           => string.Format(Culture, GetResourceString("Http2StreamResetByApplication", new [] { "errorCode" }), errorCode);

        /// <summary>A new stream was refused because this connection has too many streams that haven't finished processing. This may happen if many streams are aborted but not yet cleaned up.</summary>
        internal static string Http2TellClientToCalmDown => GetResourceString("Http2TellClientToCalmDown");

    }
}
